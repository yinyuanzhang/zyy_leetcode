## 分析
涉及动态规划几个要素理清：
dp确立：维数、代表的定义
dp初始化：考虑到如何能不越界、默认为0是否正确等因素
dp一般式: 如何写



## 具体子数组类相关题目：
1. 子数组的最大累加和  （有点类似于最基本的股票买卖)
维持两个状态变量: sum、max

2. 最长无重复子数组
简单方法: 两次遍历
哈希表：记录每个数字最新的索引位置
o(n)的复杂度：每次遍历就是right的变化。 
left的变化取决于left本身以及map存储的索引位置。 left=max(left,index) ——>有可能遇到的重复数字的位置比left还要前

3. 是否为回文子串
双指针
if(s.charAt(left++) != s.charAt(right--)) return false


4. 最长回文子串
dp[i] 以索引为i结尾的最长回文子串的大小
dp[0] = 1;
dp[i] = dp[i - 1] + 2   s.charAt(i) == s.charAt(i - dp[i - 1] - 1)
写到这里就不用继续了，思路感觉没啥问题，但就是很难写。原因就是不知道左右边界。

如果定义左右边界呢？
二维dp，dp定义为是否为回文子串。
dp[left][right]  从left到right的子串是否是回文子串 ——> boolean类型
ps: 根据一般式或者图形矩阵，需要先遍历right，再遍历left。


5. 最长公共子串 ——  两个字符串之间的比较
dp[i][j] -- 字符串str1中第i个字符和str2中第j个字符为最后元素所构成的最长公共子串。  -- 所有的dp[i][j]就是结果
if str1.charAt(i) != str2.charAt(j) dp[i][j]==0
else dp[i][j] = dp[i - 1][j - 1] + 1;  (后面的结果受前面结果的影响)


6. 最长递增子序列
本身在不断增加移动，每个结果又依赖于前面的多个结果。——> 使用动态规划的方法需要两层遍历 o(n2)
dp[i] 以i为结尾的最长递增子序列的长度
初始化可以全为1
dp[i] = Math.max(dp[i], dp[0- i-1](大于的条件))
返回字典序最小的: 降序排列——>最先遇到的为答案    res[--max] = arr[i]  (字典序理解: 留在最后的肯定就是想要的答案)




   
 







