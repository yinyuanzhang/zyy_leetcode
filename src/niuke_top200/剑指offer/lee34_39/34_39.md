## 题目分析：
34. 二叉树中和为某一值的路径
递归调用——保存结果的方式类似于回溯
3-1. 终止条件：较复杂
3-2. 循环：不是用for循环，而是遍历左右子树
3-3. 处理与回溯：每一步是针对当前函数的添加进行回溯，所以在左右子树遍历结束后执行。
ps: 本题并没有要求子树所有值都为正整数，所以 if(currSum > target) return; 的方式是很错误的。-5、+10也满足


35.复杂链表的复制
构造n个节点（包含next关系)
但是如何存储？或者说如何快速定位呢？
我去遍历旧的链表节点，就能定位到新的对应的链表节点 ——> 既然是对应的，那就是map。
第一个while(),存储成hashmap;
第二个while(),next和random链表加入。
联系下lru算法 ——> hash什么都能放


36. 二叉搜索树与双向链表
我的做法: 和复制链表方法一致； 不一样的是复制链表有random，所以需要二次处理；本题第一次中序遍历即可有序
-----------------------------
正确做法：
中序遍历的时候就处理好pre和next节点，不需要引入HashMap表。
链表节点的处理方式挺有意思。 双链表缺啥补啥   外部定义不需要传参。


37. 序列化二叉树【hard】



38. 字符串的排列
全排列问题 ——> 可以用回溯解决。 排列而非组合问题，需要使用used[]而不是startIndex
ps: 本题未说明字符各不重复，所以考虑添加hashSet来做去重处理。


39. 数组中出现次数超过一半的数字
// 方法一: 哈希表计数法
// 方法二: 排序
// 方法三：摩尔排序法 o(n) o(1) 空间复杂度为o(1)


## 完成情况
done
37.     【hard】
