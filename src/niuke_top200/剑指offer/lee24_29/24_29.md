## 题目分析：
24. 反转链表
pre curr next
对这三个节点的处理，注意curr.next要先保存

25. 合并有序链表
递归
判空后比较值


26. 判断是否是树的子结构
递归: 核心有三种情况，当前节点就对应 || 属于左子树的子结构 || 属于右子树的子结构
判断节点对应的时候: A.left == B.right && A、B左子树对应 && A、B右子树对应
终止： B为null，true； A为null，false;
特殊：1. 引用left、right需要先判断非空； 2. 题目要求空树不是任意一个树的子结构


27. 输出二叉树的镜像
输出二叉树的镜像 ——> 定义二叉树: 判空、定义root.left、 root.right;


28. 对称的二叉树
从给的例子入手更好理解。
28-1. root.left <——> root.right
28-2. <——> 实现： val == val？ 递归对称
注意判空


29. 顺时针打印矩阵
循环采用贯穿的方式，直接从一端到另一端。
while(true) ——> 一旦有不符合的，跳出循环。
统一的处理方式。（和遍历方式有关）
因为需要列的数量，所以需要判空。（一次即可）


## 完成情况:
done
