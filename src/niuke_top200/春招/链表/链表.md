## 链表定义：
int val
ListNode next

public ListNode(int val){
    this.val = val
}

## 具体链表相关题目：
1. 反转链表    迭代 ——> 改变箭头方向即可    定义 pre为null  curr
2. k组一反转   递归 ——> 函数的作用就是返回后续所有排序好的。   
先截断（head、tail，截断的重点是tail，依靠其来判断到哪里截止） 
子函数排序后    3 2 1 6 5 4    3指向6（后续）  返回1即可
解决核心是递归，意味着要判断终止条件
ps:这里的tail不在k个翻转当中。【应该是不用保存tail.next   防止0-k导致的空指针异常  翻转按需即可】

3. 链表有无环  最起码需要两个非空节点    (fast != null && fast.next != null)  敢用fast.next和fast.next.next 
4. 链表环的起点   s = cb + (n-1)*circle
快慢指针判断是否有环 ——> 有环: 头结点head与慢节点slow相遇的位置
记得需要判断链表无环的情况

5. 有序链表合并   递归写法简单
是否需要新建？  递归不需要，迭代需要 
时间复杂度都为 o(n+m) 空间 o(n+m) 和 o(1)
递归写法：好理解，注意递归写法一定要有终止条件

6. 首个公共链表节点
先叉开再合体
l1 = (l1.next == null) ? l2:l1.next  这种写法有问题：主要是 如果没有共同节点的话，将会陷入无限循环。
l1 = (l1 == null) ? l2:l1.next
null链表、正常链表、无共同节点

7. 链表中的两数相加
是否需要新建链表？  需要——>处理三个链表的移动  l1、l2移动前需要判空    l3移动前需要新建链表来保留原始节点
l1 != null || l2 != null || cache > 0 
+ 三次链表反转

8. 删除链表中的倒数第n个节点
倒数第n个 ——> 正数第x个 ——> 遍历到第x-1个，操作。
ps: 这删除一个节点的操作
一次遍历：双指针做法 + 预设一个头指针

9. 多个链表合并排序
归并排序——> 拆解、合并有序链表

10. 单个链表合并排序 [包含了快慢指针]







